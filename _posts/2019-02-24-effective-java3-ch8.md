---
layout: post
title: "Effective Java 3e Ch8"
description: "Effective Java"
date: 2019-02-24
tags: [java,pattern]
comments: true
share: true
---

## 8. 메소드
### 49. 매개변수가 유효한지 검사하라
- 오류는 가능한 빨리, (발생한 곳에서) 잡아야 한다는 일반 원칙의 사례 
- 매개변수 검사를 제대로 하지 못한 경우
  1. 메소드가 수행되는 중간에 모호한 예외를 던지면 실패할 수 있음
  2. 더 나쁜상황은 잘 수행되지만, 잘못된 결과를 반환할 때
- public과 protected 메소드는 매개변수 값이 잘못됐을 대 던지는 예외를 문서화해야함
  - ```java java.util.Objects.requireNonNull```
- 예외
  - 검사 비용이 매우 높거나, 실용적이지 않을 때
  - 계산 과정에서 암묵적으로 검사될 때
- 메소드는 최대한 범용적으로 설계해야함
  - 메소드가 건네받은 값으로 무언가를 제대로 된 일을 할 수 있다면, 매개변수 제약은 적을 수록 좋음
  - 하지만, 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 있음

### 50. 적시에 방어적 복사본을 만들라.
- 불변식을 깨뜨리려고 되어 있다고 가정하고 방어적으로 프로그래밍 해야함
- 외부 공격으로 부터 Period 인스턴스 내부를 보호하기 위해 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야함
  - 매개변수의 유효성 검사하기 전 방어적 복사본을 만들고, 복사본으로 유효성 검사를 한다는 점에 주목
  - TOCTOU 공격
    - time of check / time of use
- 매개변수가 제 3자에 의해 확자오딜 수 있는 타입일 경우, 방어적 복사본을 만들떄 clone을 사용하면 안됨


### 51. 메소드 시그니처를 신중히 설계하라
- 메소드 이름을 신중하게 
    - 이해할 수 있고, 같은 패키지에 속한 다른 이름과 일관되게 유지
    - 개발자 커뮤니티에서 널리 받아들여지는 이름 사용
    - 긴 이름을 피하고, 자바 라이브러리의 API를 참고
- 편의 메소드를 너무 많이 만들지 말라
    - 모든 메소드는 각자의 역할을 모두 해야함, 너무 많은 메소드를 가진 클래스는 유지보수가 힘듦
- 매개변수 목록을 짧게 유지
    - 4개 이하가 좋음
    - 같은 타입의 매개변수가 여러개 연달아 나오는 경우가 특히 해롭다
    - 짧게 줄일 수 있는 방법
        - 1. 메소드를 여러개로 쪼갠다
            - 직교성을 높여 쪼개진 메소드 각각은 원래 매개변수 목록의 부분집합을 받는다
        - 2. 매개변수를 여러 개 묶어주는 도우미 클래스 
        - 3. 객체 생성에 사용한 빌더 패턴을 메소드 호출에 응용
- 매개변수 타입은 클래스보다 인터페이스가 나음
- boolean보다 원소 2개짜리 열거타입이 나음
    - 이름상 boolean이 더 명확할때는 제외

### 52. 다중정의는 신중히 사용
- 오버로딩 (다중정의) 된 메소드중 어떤걸 호출할지는 컴파일 타임이 결정됨
    - [link](https://github.com/dec7/study/commit/3a05f385bbd6f7373360d6bf1b18f63e27f7eff0)
    - 오버라이딩 (재정의) 메소드는 동적으로 오버로딩 메소드는 정적 결정
        - [link](https://github.com/dec7/study/commit/1a43c6aaf712aae54814ac68d8f1679842028276)
    - 매개변수 수가 같은 다중정의는 만들지 말아야 함
        - 메소드 이름을 다르게 지을 필요가 있음
- 생성자의 경우 두번째 정의부터 무조건 다중정의가 됨
    - 정적 팩토리 메소드로 해결 가능
    - 생성자의 경우 재정의가 불가능하니 혼용될 걱정은 없음
- 다중정의라고 하더라도 매개변수가 근본적을 달라 헷갈릴일이 없다며 괜찮음 

### 53. 가변인수는 신중히 사용
- 가변인수
    - 명시한 타입의 인수를 0개 이상 받을 수 있고
    - 가변인수 수와 같은 배열을 만들어 전달
- 첫번째 인수를 무조건 전달해야하는 경우
    - 가변이자보다, 첫번째 인자를 따로 분리하라

### 54. null이 아닌 빈 컬렉션이나 배열을 반환하라
- null을 반환하게 되면 클라이언트는 항상 null을 검사해야한다
- 길이가 0인 배열은 항상 불편이므로, 미리 선언해 두고 반환할 수 있음

### 55. 옵셔널 반환은 신중히 하라
- java8 이전 특정 조건에서 값을 반환할 수 없을 때
    - 예외를 던지거나
        - 진짜 예외적인 상황에서만 사용해야하며, 예외 생성시 스택 추적 전체를 캡쳐하므로 비용도 비쌈
    - null을 던지거나
        - 클라이언트는 별도의 null처리를 해야함
- 옵셔널
    - 원소를 최대 1개 가질 수 있는 불편 컬렉션
- 옵셔널 반환을 택하는 조건
    - 반환 값이 없을 수도 있음을 API사용자에게 명확히 알려줌
    - 클라이언트가 옵셔널을 받는다면 값을 받지 못했을 때 행동을 취해야함
    - 결과가 없을 수 있고, 클라가 이상황을 특별하게 처리해야한 경우 사용
- 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안됨
- 박싱된 기본타입은 기본 타입보다 무거음
    - OptionalInt, OptionalLong,,, 등을 사용
- 옵셔널을 맵의 값으로 사용하면 안됨
    - 키의 조건이 더 많아지므로, 불필요
    - 옵셔널을 컬렉션이나 배열원소로 사용되어야 하는 상황은 거의 없음

### 56. 공개된 API요소에는 항상 문서화 주석을 작성
- 기본생성자는 문서화 주석을 달 방법이 없으므로, 공개 클래스는 절대 기본 생성자를 쓰면 안됨
- 내용
    - 무엇을 하는지 기술
    - 클라이언트가 메소드를 호출하기 위한 전제조건을 모두 나열
    - 메소드가 성공적으로 수행한 후 만족해야하는 사후조건 모두 나열
    - 부작용 (사후조건으로 명확히 나타나지는 않지만, 시스템의 상태에 어떤한 변화를 가져오는 것)
- 자주 누락되는 것
    - 쓰레드 안전성
    - 직렬화 가능성
            

