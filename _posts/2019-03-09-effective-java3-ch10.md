---
layout: post
title: "Effective Java 3e Ch10"
description: "Effective Java"
date: 2019-03-09
tags: [java,pattern]
comments: true
share: true
---

## 10. 예외
### 69. 예외는 진짜 예외상황에서만 사용
- 예
```java
// 잘못된 예
try {
  int i = 0;
  while(true) {
    range[i++].climb();
  }
} catch(ArrayIndexOutOfBoundsException e) {

}
// 개선 예
for (Mountain m : range) {
  m.climb();
}
```

- 예외는 오직 예외 상화에서만 써야하며, 일상적인 흐름제어용으로 사용해서는 안됨
- 원하지 않는 예외를 잡은 경우, 프로그램이 뜻하지 않게 종료될 수 있음
- 잘 설계된 API의 경우 클라가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야함
  - 만약 상태의존적 API의 경우, 상태검사 API도 함께 제공 필요

### 70. 복구할 수 있는 상황은 검사 예외를 프로그래밍 오류는 런타임 예외를 사용
- 예외 타입
  - 검사예외, 런타임예외, 에러
- 검사예외는 사용자에게 복구 요청
  - 복구에 대한 정보를 함께 제공하는 것이 좋음
- 런타임예외는 대부분 전제조건을 만족하지 못했을 떄이며 복구 불가능 의미
- 에러는 자원부족, 불변식 깨짐 등 더 이상 수행 불가능시

### 71. 필요 없는 검사 예외 사용은 피하라

### 72. 표준예외를 사용해라
- 장점
  - 읽기 쉬움, 클래스 로딩시간 줄음
- 비교
  - IllegalStateException
    - 인수값이 무엇이든 어차피 실패했을 거라면
  - IllegalArgumentException (아닌경우)

### 73. 추상화 수준에 맞는 예외를 던저라
- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 던진다
  - 필요시 예외 체이닝을 활용

### 74. 메소드가 던지는 모든 예외를 문서화하라
- 검사 예외는 항상 따로 선언하고, 각 예외가 발생하는 상황을 @thorws로 문서화 
  - 오직 main함수만 Exception을 던진다고 선언해도 됨
  - 비검사 예외도 같이 정리되면 좋다, @throws에는 넣지 않아도 됨

### 75. 예외의 상세 메시지에 실패 관련 정보를 담아라
- 실패 순간을 포착하기 위해 발생한 예외에 관한 모든 매개션부와 필드값의 실패 메시지를 담아야 함
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안됨
  - 상세 메시지는 친절함보다 상세한 내용이 중요

### 76. 가능한 실패 원자적으로 만들라
- 호출된 메서드가 실패해도, 객체는 메소드 호출 전 상태를 유지해야 함 (실패원자적)
- 방법
  - 불변객체로 설계
  - 작업 수행 전에 매개변수의 유효성을 검사
  - 예외 가능성 있는 코드를 상태변경 코드 앞쪽에 배치
  - 객체의 임시 복사본에서 작업을 수정 후, 작업 성공시 원래 개체와 교체
  - 실패시 상태를 복구하는 코드

### 77. 예외를 무시하지 말라
- catch 블록을 비워두면 예외가 존재할 이유가 없음
  - 어쨋든 무시할 경우 결정한 이유와 변수 이름도 ignored라고 변경하라