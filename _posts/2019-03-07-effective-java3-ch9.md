---
layout: post
title: "Effective Java 3e Ch9"
description: "Effective Java"
date: 2019-03-07
tags: [java,pattern]
comments: true
share: true
---

## 9. 일반적인 프로그래밍 원칙
### 57. 지역변수 범위를 최소화하라
- 장점
  - 코드 가독성과 유지보수 높아짐
  - 오류 가능성 낮아짐
- 방법
  - 가장 처음쓰일때 선언하기
    - 고민없이 선언할 경우, 불필요하게 많아지거나 해당 블록이 끝난뒤까지 살아있게 됨
  - 거의 모든 지역번수은 선언과 동시에 초기화 해야암
    - try-catch문은 예외로 try구문 내에서 초기화 필요
  - for 문
    - 반복 변수의 유효범위가  괄호 안으로 제한되므로 while보다 되도록 사용하는게 좋음 
  - 메소드를 작게 유지하고, 한가지 기능에 집중

- for, while 차이
```java
// while
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
    doSomething(i.next());
}

Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) {  // 컴파일, 런타임 에러가 발생하지 않으나, while문을 돌지 않고 종료
    doSomething(i.next());
}

// for
for (Iterator<Element> i = c.iterator(); i.hasNext();) {
    Element e = i.next();
    ...
} 

for (Iterator<Element> i2 = c2.iterator(); i.hasNext();) {  // i를 찾을 수 없다는 컴파일 에러
    Element e = i2.next();
    ...
} 
```

### 58. for 보다 for-each 문을 사용하라
- for문을 사용할 경우
  - 반복자라 여러번 등장하고, 타입 (컬렉션, 배열) 에 따라 코드가 변경됨
- 사용할 수 없는 상황
  - 1. 파괴적인 필터링
    - 컬렉션을 순회하면서 원소를 제거
    - java8의 경우 removeIf를 사용해 컬렉션을 명시적으로 순회하는일을 피할 수 있음
  - 2. 변형
    - 원소의 값의 일부나 전체를 교체할 경우 index로 사용 필요
  - 3. 병렬반복
    - 반복자와 인덱스를 사용하여 엄격하고 명시적으로 제어해야함

### 59. 라이브러리를 익히고 사용하라
- Random
  - java7
    - ThreadLocalRandom
  - fork-join pool, 병렬스트림
    - SplittableRandom
- 장점
  - 훨씬 훌륭한 품질
  - 시간 절약
  - 노력하지 않아도 지속적인 성능개선
  - 기능이 점점 많아짐
  - 많은 사람들에게 낯익은 코드
- 적어도
  - java.lang
  - java.util
  - java.io
  - 기타 하위 패키지
  - 특히
    - java.util.concurrent
    - 컬랙션, 스트림 프레임웍

### 60. 정확한 답이 필요할 경우 float, double은 피하라
- 이진 부동소수점 연산, 넓은 수의 점위를 빠르게 정밀한 근사치로 계산됨 
- 금융계산
  - BigDecimal, int, long 
    - BigDecimal, 느리고 쓰기불편

### 61. 박싱타입보다 기본타입을 사용
- 오토박싱, 오토언박싱으로 두 타입을 크게 구분하지 않고 사용가능하나 차이점 존재
- 차이점
  - 1. 식별성 존재  
    - 값은 같으나 다르다고 인식
  - 2. 박싱타입은 null을 가질 수 있음
  - 3. 기본타입이 시간/메모리 활용에서 더 효율적
- 오류
  - 박싱된 기본타입에 == 연산자를 사용하면 오류 발생
    - equals비교시 
  - 기본타입과 박싱된기본타입을 혼용하여 사용시
    - 박싱된 타입을 언박싱처리되고 그떄 npe발생

### 62 다른 타입이 적절할 경우 문자열 사용은 피하라
- 단점
  - 문자열은 다른 값 타입을 대신하기 부절절 
  - 문자열은 열거타입을 대체하기 부적절
  - 혼합타입을 대체하기 부적절
  - 권한(ThreadLocal의 Key)을 표현하기 부적절

### 63. 문자열 연결은 느리다
- 느림
  - 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2 비례함
  - StringBuilder는 선형적 시간증가

### 64. 객체는 인터페이스를 사용해 참조
- 적합한 인터페이스가 있는 경우 인터페이스 참조
  - 매개변수, 반환값, 변수, 필드 ..
- 예외
  - 클래스가 인터페이스의 일반규약 외 특별한 기능 제공, 의존성 있는 경우
  - String, BigInteger..
  - OutputStream 같은 java.io 패키지
  - PriorityQueue는 Queue에서 제공하지 않는 comparator 메소드 제공

### 65. 리플렉션보다 인터페이스를 사용하라
- 단점
  - 컴파일시간 타입검사가 무의미
  - 코드가 지저분해지고 장황
    - java7 모든 리플렉션의 상위 클래스 (ReflectiveOperationException)
  - 성능 저하
- 용법
  - 아주 제한된 형태로 사용하고, 이점만 취득
  - 인스턴스 생성시만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용

### 66. 네이티브 메소드는 신중히 사용
- jni 쓰임새
  - 1. 레지스트리 같은 플랫폼 특화기능
    - 하지만 최근 java9에서는 processAPI 를 추가해 OS프로세스에 접근 가능
  - 2. 네이티브 코드로 작성된 기존 라이브러리 사용
  - 3. 성능 개선 
    - 비권장, 최근 jvm성능 발전

### 67. 최적화는 신중하게
- 하지마라
- 성능을 제한하는 설계를 피하라
- api설계시 성능에 주는 영향을 고려
- 성능을 위해 api를 왜곡하는건 매우 안좋다
- 최적화 시도전후를 측정 후 비교 필요

### 68. 일반적으로 통용되는 명명규칙을 따르라
- 대상
  - 패치키 클래스, 인터페이스, 메소드, 필드, 타입, 변수
- 패키지
  - 모든 요소롤 통용하는 8자 이하 약어
- 클래스, 인터페이스
  - 완전 통용되는 약어를 제외한 약어 제외 