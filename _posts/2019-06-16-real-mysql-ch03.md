---
layout: post
title: "Real MySql Ch03"
description: "Real MySql Ch3"
date: 2019-06-16
tags: [sql,anti,pattern]
comments: true
share: true
---

## mysql 아키텍쳐

### 3.1.1 MySql 전체구조
```
- 응용프로그램
    - 커넥션 api 
- mysql 서버 
    - mysql 엔진
        - 커넥션 헨들러
        - sql 인터페이스, sql 파서, sql 옵티마이저, 캐시/버퍼
    - 스토리지 엔진
        - InnoDB, MyISAM, Memory, ..
- 운영체제 / 하드웨어
    - 디스크 파일시스템
    - 데이터 및 로그파일 
```
- mysql 엔진
    - 클라이언트로부터 접속, 쿼리 요청을 처리하는 커넥션 핸들러 
    - sql 파서, 전처리기, 옵티마이저 
    - 성능향샹 위한 캐시, 버퍼풀 같은 보조 저장소 

- 스토리지 엔진
    - mysql 엔진은 요청된 sql 분석, 최적화 등 dbms의 핵심기능 수행
    - 실제 데이터를 디스크 스토리지에 저장, 조회하는 부분은 스토리지 엔진이 담당 
    - mysql은 한 서버에 여러개의 스토리지 엔진을 사용할 수 있음 

- 핸들러 api 
    - 핸들러 요청
        - mysql 엔진 쿼리 실행기에서 데이터를 읽거나 쓸때, 각 스토리지 엔젠에게 쓰기/읽기를 요청 
    - InnoDB 스토리지 엔진도 핸들러 API를 사용해 MySQL 엔젠과 데이터를 주고 받음
        - ```sql show global status like 'Handler%'; ```

### 3.1.2 MySQL 스레딩 구조
- 프로세스가 아닌 스레드 기반으로 동작하며, 포그라운드 스레드 / 백그라운드 스레드가 있음 

#### 포그라운드 스레드  (사용자 스레드)
- 최소 mysql서버에 접속된 클라이언트 수만큼 존재
- 주로 각 클라이언트가 요청한 쿼리 문장을 처리하는 것이 임무 
    - 클라이언트 작업이 마무리 되면, 커넥션 담당 스레드는 다시 스레드 풀로 돌아감 
    - thread_cache_size 에 따라 이 크기를 넘으면 풀에 넣지 않고 종료
- 데이터를 mysql 데이터 버퍼나 캐시로부터 가져옴 
    - 버퍼, 캐시에 없는 경우 직접 데스크의 데이터나 인덱스 파일로 부터 데이터를 읽어와서 작업을 처리 
- MyISAM 데이블
    - 디스크 쓰기 작업까지 포그라운드 스레드가 처리 (지연쓰기 기능이 있으나 일반적이지 않음)
- InnoDB 테이블 
    - 데이터 버퍼나 캐시까지 포그라운드 스레드가 처리
    - 나머지 버퍼로부터 디스크 기록작업은 백그라운드 스레드가 처리 

#### 백그라운드 스레드 
- MyISAM은 큰 해당사항 없음
- InnoDB의 경우 여러 작업을 처리
    - 인서트 버퍼 (Insert Buffer) 를 병합하는 스레드
    - 로그를 디스크로 기록하는 스레드
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽어들이는 스레드
    - 여러 기타 잠금처리 스레드 
    - 데드락 모니터링 스레드
    - 스레드 총괄 스레드
- 가장 중요 스레드
    - 로그 스레드 
    - 쓰기 스레드 
        - innodb_write_io_threads
        - 윈도우 5.0 버전부터 1개 이상 지정 
        - 리눅스.유닉스 5.1 버전부터 1개 이상 지정
        - 읽기 쓰레드의 경우 클라이언트 스레드에서 처리되기 때문에 많이 필요없으나, 쓰기 쓰레드는 아주 많은 작업을 백 그라운드로 처리하므로 일반적인 내장디스크시 2~4, DAS/SAN 스토리지시 4개 이상으로 설정 
- 읽기 쓰레드 
    - innodb_read_io_threads


#### 특징
- sql 처리 중, 쓰기 작업은 지연처리 가능하나, 읽기 작업은 절대 지연될 수 없음  
    - 일반적은 dbms의 경우 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능 탑재됨 (InnoDB 포함)
    - MyISAM의 경우 사용자 스레드가 쓰기 작업까지 처리하도록 설계됨 
- InnoDB
    - insert, update, delete 쿼리로 데이터가 변경되는 경우 완전 저장될때까지 기다리지 않아도 됨
- MyISAM
    - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없음 

### 3.1.3 메모리 할당 / 사용구조
```
- MySQL 서버
    - 글로벌 메모리 영역
        - 키 캐시 (MyISAM)
        - 버퍼 풀 (InnoDB)
        - 쿼리 캐시 
        - 바이너리 로그 버퍼
        - 로그 버퍼 
        - 테이블 캐시
    - 로컬(세션) 메모리 영역
        - 커넥션 버퍼
        - Result 버퍼 
        - Read 버퍼
        - 조인 버퍼 
        - 랜덤 Read 버퍼 
        - 정렬 (Sort) 버퍼 
```

- 글로벌 메모리 영역은 MySql 서버가 실행되면서 무조건 운영체제로부터 할당됨 
    - os에 따라 100%할당해 줄수도 있고, 그 공간만큼 예약해두고 조금씩 할당하는 경우도 있음 
    - MySql서버가 사용하고 있는 정확한 메모리 양을 측정하는 일은 복접/어려움, 그냥 할당받는다고 생각 

#### 글로벌 메모리 영역
- 클라이언트 스레드의 수와 무관하게 일반적으로 하나의 메모리 공간만 할당됨 
    - 단, 필요에 따라 2개 이상 메모리 공간을 할당받을 수 있지만, 클라이언트 스레드 수와 무관 
    - 생성된 글로벌 영역이 N더라도, 모든 스레드에 의해 공유됨 

#### 로컬 메모리 영역 (클라이언트 메모리 영역)
- 세션 메모리 영역
- MySQL 서버상 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역 
    - 커넥션 버퍼, 정렬 버퍼 
- 클라가 MySQL 서버에 접속시 서버는 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당 
    - 클라이언트 스레드가 사용하는 메모리 영역
- 각 스레드별로 독립적, 절대 공유되지 않음 
- 일번적으로 글로벌 메모리 영역 크기는 주의해서 설정하나,
    - 로컬메모리 영역은 크기 신경쓰지 않고 설정하게 되는데, 최악의 경우 MySQL 서버가 메모리 부족으로 멈출수도 있음 
- 중요한 특징
    - 각 쿼리 용도별로 필요할때만 공간이 할당되고, 필요하지 않는 경우엔 MySQL이 메모리 공간을 할당조차 하지 않을 수 있음
        - 소트 버퍼, 조인 버퍼
    - 커넥션이 유지되는 동안 할당되어 있을 수도 있고, 쿼리가 실행될때만 할당될 수도 있음 

### 3.1.4 플러그인 스토리지 엔진 모델
- MySQL의 독특한 구조 중 하나 
- 플러그인 모델
    - 스토리지 엔진, 전문 검색엔진을 위한 검색어 파서 
- 쿼리가 실행되는 과정
    - sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/쓰기
    - 데이터 읽기/쓰기 작업
        - 거의 대부분 1건의 레코드 단위로 처리 됨 
- 헨들러 
    - mysql 엔진이 각 스토리지 엔진에게 데이터 읽기/쓰기 명령하기 위해 꼭 통해야만 함
    - Handler_* 로 시작하는 상태변수는 MySQL엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수 
- 복잡한 처리는 MySQL 엔진의 처리 영역인 "쿼리 실행기"에서 수행됨 
    - group by, order by ..
- 중요점
    - 하나의 쿼리 작업은 여러 하위작업으로 나뉠 수 있으며 
    - 그 하위 작업이 MySQL엔진 혹은 스토리지 엔진에서 처리되는지 구분할줄 알아야 함 

#### mysql engines;
- ```sql show engines; ```
- support 칼럼
    - yes: mysql 서버에 해당 스토리지 엔진이 포함되어 있고, 사용 가능 상태 
    - default: yes와 동일한 상태 + 필수 스토리지 엔진 
    - no: mysql 서버에 포함되지 않음 
        - 사용하기 위해 mysql 서버를 다시 빌드 하거나, 플러그인 설치 필요
    - disabled: mysql 서버에 포함되었으나 비활성화됨 


### 3.1.5 쿼리 실행 구조 
- 과정 
```
- sql 요청
- 쿼리 컴파일러
    - 쿼리파서 -> 전처리기 -> 옵티마이저 (쿼리 변환, 비용최적화, 실행계획 개선)
- 쿼리 실행기
    - 스토리지 엔진 -> 하드웨어
    - sql 반환
```

####  파서
- 사용자에게 요청된 쿼리 문장을 토큰으로 분리, 트리 형태 구조로 만듦 
- 기본 문법 오류 감지

#### 전처리기 
- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인 
- 각 토큰을 테이블 이름 / 칼럼이름 / 내장함수 같은 개체를 매핑해 
    - 객체 존재여부, 접근권한 확인

#### 옵티마이저 
- 요청된 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할 담당 
- dbms의 두뇌, 이책 대부분 내용이 옵티마이저가 선택하는 내용을 설명하는 것 
    - 옵티마이저를 잘 유도하는 법 

#### 실행엔진 
- 옵티마이저가 두뇌, 실행엔진-핸들러는 손/발 비유
- 예 (group by 를 처리하기 위해 임시테이블을 사용하기로 결정)
    - 실행엔진은 핸들러에게 임시 테이블을 만들라고 요청 
    - 실행엔진은 핸들러에게 where절에 일치하는 레코드를 읽어오라고 요청
    - 실행엔진은 핸들러에게 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 요청
    - 실행엔진은 핸들러에게 임시테이블에서 필요한 방식으로 데이터를 읽어오라고 요청
    - 실행엔진은 최종결과를 사용자나/다른 모듈로 넘김

#### 핸들러 (스토리지 엔진)
- mysql 실행엔진의 요청에 따라 데이터를 디스트로 저장/읽는 역할 

### 3.1.6 복제 (replication)
- 과정
```
웹서버 
    - insert, update, delete, select
        - 마스터 mysql
            - 바이너리 로그 스레드 -> 바이너리 로그 -> 바이너리 로그 덤프 스레드
    - select
        - 슬레이브 mysql
            - replication io 스레드 -> 릴레이 로그 -> replication sql 스레드 
```

- 확장성
    - db가 대용량화 -> 확장성은 중요한 요소 
    - 확정성 지원 중 일바적인 방법이 복제 
- 복제 (replication)
    - 2개 이상의 mysql 서버가 동일한 데이터를 담도록 실시간 동기화 하는 기술 
    - 변경전용, 일기전용 mysql 서버로 나누면, 전자를 마스터, 후자를 슬레이브라고 함
    - 일반적으로 마스터는 반드시 1개, 슬레이버는 1개 이상으로 구성
- 역할
    - mysql서버는 마스터/슬레이브 하나의 역할만 수행하나, 때로는 두가지 역할을 하기도 함

#### 마스터
- 기술적으료 mysql의 바이너리 로그를 활성화하면 마스터가 될 수 있음 
- 복제를 구성하는 경우, 여러 서버중, 변경이 허용되는 서버는 마스터로 한정할때가 많음 
    - 일관성 유지 위해 
    - 마스터는 dml, ddl 모두 바이너리 로그에 기술 
- 슬레이브 서버에서 변경내역 요청시, 마스터 장비는 바이너리 로그를 읽어 슬레이브로 전달 
    - binlog dump 스레드 
    - 연결된 슬레이브 만큼의 스레드가 생성됨 

#### 슬레이브
- 바이너리 로그를 받아 올 마스터 장비의 정보 (ip, port, 접속 계정) 가지고 있으면 슬레이브가 됨 
- 릴레이 로그를 가짐 
    - 마스터와 슬레이브 데이터를 동일한 상태로 유지하기 위해 슬레이브는 읽기 전용으로 설정
    - 슬레이브 서버의 io스레드는 마스터 서버에 접속해 변경내역 요청
    - 받아온 로그를 릴레이 로그에 기록
- 슬레이브 서버의 sql스레드가 릴레이 로그에 기록된 변경내역을 재실행하여 마스터와 동일한 상태를 유지 
    - io스레드, sql스레드는 마스터에서는 기동되지 않음 
    - 복제 설정된 슬레이브 mysql 서버에서 자동적으로 기동됨 


#### 주의사항
- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정 
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합 
- 복제가 불필요한 경우에는 바이너리 로그 중지 
    - 바이너리 로그를 안정적으로 기록하기 위해 갭락을 유지 
    - 매번 트랜잭션이 커밋될때마다 데이터를 변경시킨 쿼리 문장을 바이너리 로그에 기록 
    - AutoCommit 이 활성화된 mysql서버에서 더 큰 부하 
        - 트랜잭션지원하지 않는 myisam 데이블은 항상 auto commit 모드이므로 바이너리 로그 기록시 더 많은 자원 사용
- 바이너리 로그의 트랜잭션 격리 수준
    - 어떤 내용이 기록되는지에 따라 statement 포멧/ row포멧 방식 있음
    - statement 포멧 방식 (문장 기반 복제)
        - 마스터에서 실행되는 쿼리 문장 기록
        - mysql 5.0 이하까지 statement만 지원 
        - 마스터/슬레이브 데이터 일치를 위해 repeatable read 격리 수준만 사용 가능 
            - insert info ... select .. from.. 형태 사용시 주의
        - 데이터 변경이 많더라도 네트워크 트래픽이 적음 
            - 정상작동 위해 repeatable read 수준 잠금 필요
            - InnoDB에서 레코드간 간격을 잠그는 갭락이나, 넥스트 키 락 필요
    - row 포멧 방식 (레코드 기반 복제)
        - 마스터에서 실행된 쿼리에 의해 변경된 레코드 값을 기록 
        - 네트워크 트래픽 많아질 수 있으나, read-commited 트랜잭션 격리 수준에서도 동작
        - InnoDB에서 잠금 경합은 줄어듦

### 3.1.7 쿼리 캐시 
- 과정
```
- sql 요청
    - 쿼리 캐시에서 캐시된 결과 검색
    - 결과가 있는 경우 즉시 반환
    - 없는 경우, 
        - 이전과 동일.
```
- 복잡한 처리 절차 + 큰 비용으로 실행된 결과를 쿼리캐시에 담아 두고, 동일한 요청시 캐시에서 찾아 바로 반환 
- sql 문장이 아닌, 쿼리 결과를 캐시 
    - 문장 -> 키, 쿼리 결과 -> 값 

#### 문장이 동일하다고 캐시된 결과를 줄수 없으므로 복잡한 절차로 확인함 
- 요청된 쿼리 문장이 쿼리 캐시에 있는지
    - 아주 간단히 빠르게 확인하는 절차를 가짐
    - 비교 방식은 문장이 동일한지 여부
        - 공백, 탭 모두 포함, 대소문자 구별 
- 해당 사용자가 결과를 볼수 있는 권한이 있는지
- 트랜잭션 내에 실행된 쿼리인 경우, 결과가 가시범위 내의 트랜잭션에서 만들어졌는지 (InnoDB)
    - InnoDB의 모든 트랜잭션은 id를 가지고, 트랜잭션이 시작된 시점을 기준으로 순작으로 증가하는 6바이트 숫자 값 
    - 자신 트랜잭션 id보다 큰 id를 참조할 수 없음 (가시범위 )
- 쿼리에 사용된 기능이 캐시돼도 동일한 결과를 보장하는지 
    - current_date, sysdate, rand : 호출 시점마다 달라지는지 
        - 호출시간에 따라 결과가 달라짐
        - not determinitic 으로 정의된 내장함수 
    - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는지 
        - 프리페이드 스테이으먼트: 바인드 변수가 사용된 쿼리 
        - 문장자체에 ?가 사용되므로 문장 자체로 쿼리 캐시를 찾을 수 없음 
        - 프로그램 코드에서 프리페어 스테이트먼트 사용한다고 적용 안됨
            - 커넥션 생성시 특별한 옵션을 추가 -> 서버사이트 프리페어 스테이트 먼트 
            - 5.1부터 프리페어 스테이트먼트로 생성된 쿼리도 쿼리 캐시 가능 
- 캐시가 만들어진 후, 데이터가 다른 사용자에 의해 변경되지 않았는지 
    - 쿼리 결과가 캐시된 후 변경시 캐시하는건 무의미하므로 무효화해야함 
    - 캐시는 빠른 성능을 위해 아주 단순하게 구현됨 
    - 데이터를 무효화 하는 것은 레코드가 아닌 테이블 단위로 진행 
    - 쿼리 캐시가 클 경우 무효화 시에도 시간이 많이 걸리, 적절한 크기 (32m ~ 64m)를 설정하는게 필요
    - 주의
        - 갱신, 조회가 필요한 경우, 쿼리 캐시는 사용할 수 없는 상태 
        - 이런 경우 조회수 칼럼을 다른 테이블로 분리하거나, 조회수를 일정 누적 후 한번에 업데이트
- 쿼리에 의해 만들어진 결과가 과도하게 크지 않는지 
    - query_cache_limit, 1~2m 미만으로 설정
    - 결과 크기가 작을수록 캐시가 효율적으로 동작
        - group by, distinct, count 같은 함수 
- 그 밖에 캐시를 사용하지 못하는 요소가 있는지
    - 임시 테이블 
    - 사용자 변수 (프리페어와 동일한 효과 )
    - 컬럼기반 권한 설정
    - lock in share mode 힌트 
        - select 문장 끝에 붙여서 조회하는 레코드에 공유잠금(읽기 락 )을 설정 
    - for update 힌트 
        - select 문장 끝에 붙여서 조회하는 레코드에 배타적 잠금 (쓰기 락)을 설정 
    - udf (user defined function )  tkdyd
    - 독립적인 select가 아닌, 일부분의 서브쿼리 
    - 스토어드 루틴에서 사용된 쿼리 
        - procedure, function, trigger
    - sql_no_cache 힌트 
        - select 문장에서 select 키워드 뒤에 붙이는 힌트ㅓ
        - 쿼리 캐시 사용 안함 / 애플리케이션에서 사용되는 쿼리에 의도적으로 이 힌트를 사용하는 경우는 거의 없고, 쿼리 성능을 테스트하기 위해 사용됨 

- 쿼리 캐시를 사용에 제약이 많지만 효과는 높음
    - show global status 명령으로 상태 확인 가능
        - Qcache_hits, Com_select 로 얼마나 효율적인지 확인 가능
        - 캐시 히트율: Qcache_hits / (Qcache_hits + Com_select) * 100
        - 보통 히트율이 20% 이상이면 쿼리 캐시가 좋다고 하지만, 1%만 사용하더라도 소모 자원이 크다면 좋은 선택이 될 수 있음
    - 쿼리 캐시를 쓰지 않기 위해 아래 설정 필요
        - query_cache_size = 0, query_cache_type = 0

## 3.2 InnoDB 스토리지 엔진 아키텍쳐
- MySQL에서 유일하게 레코드 기반 잠금을 제공 
- 엔진 구성
    - MySQL 엔진
        - 쿼리 옵티마이져 <-> 쿼리 실행기 => 핸들러 API
    - InnoDB 스토리지 엔진
        - 메모리 영역
            - InnoDB 버퍼 풀
                - 언두 레코드
                - 인서트 버퍼
                - 데이터 페이지 버퍼 
            - 로그 버퍼
        - CPU연산 영역
            - 인서트 버퍼머지 스레드 
                - 인서트 버퍼 => 스레드 => 데이터 페이지 버퍼
            - Write 스레드
                - 언두 레코드 => 스레드
                - 데이터 페이지 버퍼 => 스레드
            - 기타 스레드
            - 로그 스레드
                - 로그버퍼 => 스레드
        - 디스크 스토리지 영역
            - 시스템 데이블 스페이스 
            - 사용자 테이블 스페이스 
            - 리두 로그 

### 3.2.1 InnoDB 스토리지 엔진 특성

#### 프라이머리 키에 의한 클러스터링
- 모든 테이블은 프라이머리 키를 기준으로 클러스터링 (키 순서대로 디스크에 저장)
- 프라이머리 키에 의한 레인지 스캔은 상당히 빠름 
    - 쿼리 실행계획에서 프라이머리 키는 다른 보조 인덱스에 비해 비중이 높게 설정될 수 있음 
- 오라클 DBMS의 IOT(Index Organized Table)과 동일 구조

#### 잠금이 필요없는 일관된 읽기 
- InnoDB는 MVCC(Multi version concurrency control) 기술로 락을 걸지 않고 읽기 작업을 수행
- 락을 걸지 않으므로 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지 않음
    - serializable 제외 

#### 외래키 지원
- MyISAM, Memory 에선 지원 않함
- 부모, 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요 
- 변경시 반드시 부모 테이블이나, 자식 테이블에 데이터가 있는지 체크하는 작업 필요하므로 잠금이 여러 테이블로 전파 -> 데드락 발생 가능

#### 자동 데드락 감지
- InnoDB는 그래프 기반 데드락 체크 방식 사용 
    - 데드락이 발생함과 동시에 감지 
- 감지된 데드락은 관련 트랜젝션 중에서 rollback이 가장 용이한 트랜잭션 (rollback시 복구작업이 가장 작은 트랜잭션, 레코드를 가장 적에 변경한 트랜잭션) 을 자동적으로 종료 시킴
- 데드락 때문에 쿼리가 제한시간에 도달하는 경우는 많지 않음 

#### 자동화된 장애 복구
- 장애시 데이터를 보호하기 위한 여러 메커니즘 보유
- MySQL 서버 시작시, 완료되지 않은 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지에 대한 일련의 복구작업이 자동 진행 

#### 오라클의 아키텍처 젹용
- InnoDB 스토리지 엔진은 오라클 DBMS와 상당히 비슷 
    - MVCC, 언두 데이터가 시스템 데이블 스페이스에 보관, 테이블 스페이스 개념 

### 3.2.2. InnoDB 버퍼 풀 
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분 
    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 
    - 쓰기 지연 작업도 버퍼 역할이 같이 함 
        - 일반적인 어플리케이션은 insert, update, delete와 같은 데이터 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경, 랜덤한 디스크 작업을 발생시킴
        - 버퍼풀은 변경 데이터를 모아서 처리하여 랜던함 디스크 작업 횟수를 줄임 

- MyISAM 키 캐시와 다르게 InnoDB 버퍼 풀은 데이터/인덱스를 모두 캐시 + 쓰기 버퍼링 역할까지 처리 
- 버퍼풀은 백그라운드 작업의 기반이 되는 메모리 공간 
    - InnoDB 버퍼풀 설정 (innodb_buffer_pool_size) 은 신중해야 함 
    - 물리 메모리를 기준으로 단순설정은 안되며, OS/클라 쓰레드가 사용하는 메모리를 고려해 설정 (50~80%)

- InnoDB 버퍼풀은 아직 디스크에 기록되지 않은 변경된 데이터를 보유 (Dirty Page)
    - 더디 페이지는 주기적으로 어떤 조건이 되면 체크 포인트 이벤트 발생 
    - 이때 write 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록 

### 3.2.3 언두 로그 
- 연두 영역은 update문장, delete 문장으로 데이터 변경했을 때 변경전의 데이터를 보관하는 곳 

```sql
> UPDATE member SET name = 'hong' WHERE member_id = '1';
```

- 위 문장 실행시, 트랜잭션을 커밋하지 않아도 실제 데이터 파일 (데이터/인덱스 버퍼) 내용은 변경됨
    - 그리고 변경 전의 데이터를 언두 영역에 백업 됨 

#### 용도 
- 1. 트랜잭션 롤백 대비용
- 2. 트랜잭션 격리수준을 유지하면서 높은 동시성 유지 
    - 트랜잭션 격리 수준: 동시에 여러 트랜잭션이 데이터를 변경/조회시 한 트랜잭션이 작업 내용이 다른 트랜잭션에 어떻게 보여질지 결정하는 기준 

### 3.2.4 인서트 버퍼 
- RDBMS에서 레코드가 insert/update 될 때 데이터를 변경하는 작업과 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요 
    - 그런데 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하여 데이블 인덱스가 많은 경우 상당히 많은 자원을 소모 
    - InnoDB는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 바로 수행, 아닌 경우 임시공간에 저장하고 사용자에게 바로 결과를 반환하는 형태로 성능 향상 
    - 이때 사용하는 임시공간이 인서트 버퍼 

#### 유니크 인덱스 사용불가
- 결과 전달전 반드시 중복여부를 체크 필요

#### 인서트 버퍼 머지 스레드 
- 인서트 버퍼에 임시로 저장된 인덱스 레코드 조각은 백그라운드 스레드로 머지됨 
- 5.5 이전까진 insert만 버퍼링 지원되었으나, 5.5부터는 insert, delele로 키 추가/삭제 작업에 대해서도 지원 
- 5.5 부터 innodb_change_buffering 으로 작업 종류별로 구분 가능 

### 3.2.5 리두 로그 및 리두 버퍼 
- 쿼리 문장으로 데이터 변경 / 커밋시 DBMS는 ACID보장 위해 즉시 데이터를 파일로 기록 
    - 순차적으로 변경시 랜덤하게 기록해야하므로 디스크 부하 큼
    - 부하를 줄이기 위해 버퍼풀이 존재하나 ACID보장 어려움
        - 변경된 내용을 순차적으로 디스크에 기록하는 로그파일 보유 -> 리두 로그

- 눈으로 확일할 수 없으며, 그럴 필요도 없음
- 리두 로그로 높은 성능향상 보장하나 변경작업이 매우 많은 dbms의 경우 리두로그 기록 작업이 문제가 됨 
    - 위 문제를 보완하기 위해 최대한 ACID를 보장하는 수준에서 버퍼링 -> 로그 버퍼
    - 일반적으로 1~8M 수준, blob, text가 많은 경우 더 크게 설정 
- ACID
    - 원자성, 일관성, 격리성, 지속성

### 3.2.6 MVCC (multi version concurrency control)
- 일반적으로 레코드 레벨 트랜잭션을 지원하는 DBMS가 제공하는 기능 
- 목적
    - 잠금을 사용하지 않는 일관된 읽기를 제공
- InnoDB는 언두 로그로 이 기능을 구현
- 멀티버전
    - 하나의 레코드에 대해 여러 개의 버전이 동시에 관리 

```sql
> CREATE TABLE member (
    m_id    INT NOT NULL,
    m_name  VARCHAR(20) NOT NULL,
    m_area  VARCHAR(20) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);
> INSERT INTO member (m_id, m_name, m_area) VALUES (12, 'Hone','Seoul');
> COMMIT;
```

- 위 실행 후
    - InnoDB 버퍼풀: 포함
    - Undo 로그: 있을수도 있고, 없을수도 있음
    - 디스크: 기록

```sql
> UPDATE member set m_area = 'Pangyo' WHERE m_id = 12;
```

- 위 실행 후
    - InnoDB 버퍼풀: 'Pangyo'
    - Undo 로그: 'Seoup'
    - 디스크
        - 버퍼풀을 즉시 디스크로 기록하지 않고 일정 주기마다 기록하므로 알 수 없음
        - 백그라운드 스레드에 따라 달라짐
        - ACID를 보장하므로 버퍼풀과 디스크는 동일하다고 가장해도 무방함 

```sql
> SELECT * FROM member WHERE m_id = 12;
```

- 위 실행 후
    - commit, rollback 되지 않은 상태에서 위 쿼리 실행 결과는 격리수준에 따라 달라짐
        - READ_UNCOMMITED
            - 커밋, 롤백과 관계없이 변경된 상태를 반환 (버퍼풀, 디스크)
        - READ_COMMITED, REPEATABLE_READ, SERIALIZABLE
            - 커밋되지 않았으므로 언두 영역의 데이터를 반환


#### 결론
- 위 과정이 mvcc, 하나의 레코드에 대해 2개 버전이 유지, 필요에 따라 반환된 데이터가 달라질 수 있음
- 트랜잭션이 많거나 길어질 경우 예전 데이터가 오랫동안 유지되어야 하므로 언두 영역이 저장되는 시스템 데이블 스페이스 공간이 많이 필요할 수 있음 

#### 과정
- update 쿼리 실행시 버퍼풀은 즉시 새로운 데이터로 변경, 기존 데이터는 언두 영역으로 복사
- commit 실행시 지금 상태를 영구적으로 변경
- rollback 실행시 언두 영역의 백업 데이터를 버퍼풀로 복구 후 언두 내용 삭제 
    - 언두 역시 바로 삭제되는 건 아니며, 언두 영역이 필요한 트랜잭션이 없을때 삭제

### 3.2.7 잠금 없는 일관된 읽기 
- 격리수준이 READ-UNCOMMITED, READ-COMMITED, REPEATABLE-READ 인 경우 
    - insert가 없는 순수 select 작업은 다른 트랜잭션 변경과정과 관계없이 항상 잠금을 대기하지 않고 바로 실행
    - 특정 사용자가 레코드 변경 후 아직 커밋하지 않았다고 하더라도 select 작업을 방해하지 않음 
- InnoDB는 변경전의 데이터를 읽기 위해 언두 로그를 사용 
- MySQL 서버가 느려지거나 문제가 발생한 경우 
    - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생
    - 트랜잭션이 시작시 가능한 빨리 롤백 / 커밋 하여 트랜잭션을 완료해야 함 

### 3.2.8 InnoDB와 MyISAM 스토리지 엔진 비교
#### 캐시 
- MyISAM 엔진 인덱스를 위한 키 캐시를 가지나 데이터 자체는 OS의 캐시에 의존
- InnoDB 엔젠은 자체적인 버퍼풀로 좀 더 업무에 맞는 버퍼링 수행
    
#### 트랜잭션 관리, 레코드 수준 잠금 관리
#### 전문 검색 
- MyISAM의 장점이나 제약이 있음

#### InnoDB의 단점
- MySQL 서버의 설정 튜님이 까다롭다는 것 

### 3.2.9 InnoDB와 Memory (heap) 스토리지 엔진 비교 
- 메모리 스토리지의 장점
    - 데이터와 인덱스를 모두 메모리에 저장하여 읽기 작업이 매우 빠름
    - 하지만, 동시성이 높다는 말과는 다름
    - 테이블 수준의 잠금을 이용
        - 동시에 두개 이상의 클라이언트가 테이블을 변경할 수 없음 
- 메모리가 충분할 경우 레코드 수준의 잠금을 지원하는 InnoDB가 훨씬 빠른 트랜잭션을 보장
    - Memory 테이블은 여러커넥션 읽기 위주나 단일 커넥션엔 적합하나
        - 동시에 많은 트랜잭션을 유발하는 oltp 환경에서는 적합하지 않음 

## 3.3 MyISAM 스토리지 엔진 아키텍쳐 
- 구조 
```
- MySQL 엔진
    - 쿼리 옵티마이저 <-> 쿼리 실행기 -> 핸들러 API 통신
- MyISAM 스토리지 엔진 
    - 메모리 영역
        - 키 캐시
    - 운영체제 캐시 영역
        - 운영체제의 시스템 캐시 / 버퍼
    - 디스크 스토리지 영역
        - 인덱스 파일
            = 키 캐시 => os 캐시 => 인덱스 파일
        - 데이터 파일
            = os 캐시 <=> 데이터 파일
```

### 3.3.1 키 캐시 
- 인덱스를 대상으로 작동, 인덱스의 디스크 쓰기작업에 대해서만 부분적으로 버퍼링 역할 
- 히트율
    - 100 - (Key_reads / Key_read_requests * 100)
        - Key_reads: 인덱스를 디스크에서 읽은 횟수
        - Key_read_requests: 키 캐시로부터 인덱스를 읽은 횟수 
- 메뉴얼에서는 키 캐시를 이용한 쿼리의 비율을 99% 이상으로 유지하라고 가이드 
    - 만약 99% 미만의 경우 키 캐시를 더 크게 하는게 좋음 
    - 32,64bit 컴퓨터 모두 4G 이상 메모리 공간 설정 불가 
    - 그 이상 설정하고 싶은 경우 Default 키캐시 외에 별도의 키 캐시 공간 설정 필요

```
key_buffer_size = 4GB
kbuf_board.key_buffer_size = 2GB
kbuf_comment.key_buffer_size = 2GB
```
- 이후, MyISAM 스토리지 인젠에 설정
```
CACHE INDEX board IN kbuf_board;
CACHE INDEX comment IN kbuf_comment;
```

### 3.3.2 운영체제의 캐시 및 버퍼 
- MyISAM 테이블은 디스크 IO를 처리할 캐시/버퍼링 기능이 없음 
    - 항상 os에 쓰기,읽기 작업을 요청될 수 밖에 없음 
    - OS자체적인 매커니즘에 의한 캐시/버퍼링에 의존함
        - OS의 캐시 공간은 os의 남는 메모리 공간을 쓰는것이 기본 원칙, 그래서 캐시할 메모리 공간이 없어지 ㄹ수 있음
- 키 캐시는 os메모리 공간의 40% 넘지 않게 설정 필요
    - os가 자체적인 파일시스템 위한 캐시 공간 마련 필요

## 3.4 Memory 스토리지 엔진 아키텍처 
- heap 스토리지 엔진
- 데이터가 아주 작고, 빠른 처리가 필요할때 적합

### 3.4.1 주의 사항
#### 테이블 최대 크기 
- max_head_table_size로 지정
- 글로벌 + 세션 + 동적변경 가능 변수로 해당 커넥션에서만 파라미터를 재설정 가능

#### 고정 길이 칼럼 지원
- varchar(100)으로 설정하더라도 char(100)이 할당됨 
- 불필요하게 큰 데이터 타입을 사용하지 않는게 좋음 

#### blob, text 타입 미지원

#### memory 테이블은 기본적으로 해시 인덱스 사용
- InnoDB, MyISAM 테이블은 별도 명시하지 않은 경우 B-Tree 인덱스가 생성
- Memory 의 경우 해시 인덱스를 생성

### 3.4.2 용도 
- 명시적으로 생성할 수 도 있지만, MySQL 엔진이 쿼리를 처리하는 과정에서 임시로 생성하는 임시테이블 용도로 더 자주 사용됨
- 임시테이블의 특징은 해당 커넥션에서만 유효 

## 3.5 NDB 클러스터 스토리지 엔진 
- NDB 클러스터는 다른 스토리지 엔진과 작동방식/용도가 많이 다름 
- 네트워크 데이터 분산 지원 스토리지 엔진
- NDB 클러스터
    - 데이터 분산, 성능향상보다 가용성에 집중된 스토리지 엔진

### 3.5.1 NDB 클러스터 특성 
#### 무공유 클러스터링 
- 클러스터 그룹내의 모든 노드가 아무것도 공유하지 않는 무공유 아키텍쳐로 구현
- 오라클 RAC (Real Application 클러스터) 는 데이터 저장소를 공유하는 형태로 구현   
    - 클러스터 그룹내에 하나만 존재 + SPoF 가 될 수 있음
- NDB클러스터는 데이터를 저장하는 스토리지도 분산되어 SPoF가 없음 
- 관리노드, 데이터노드, SQL노드 (API노드) 구성 
    - 모두 이중화 해서 구현 가능

#### 메모리 기반 스토리지 엔진
- 기본으로 메모리를 데이터 스토리지로 사용
    - 최근엔 디스크 기반도 지원하나 노드간 빠른 데이터 공유를 위해 메모리를 사용하는게 일반적 
- 각 노의 물리적 메모리를 모두 합친게 저장 가능한 최대 용량
- 저장소가 메모리므로 모든 저장소가 재시작되면 클러스터의 모든 데이터가 사라질 수 있음
    - 주기적으로 메모리의 데이터를 디스크에 기록

#### 자동화된 페일오버
- NDB 클러스터는 모든 구성 노드가 서로의 상태를 체크, 특정 노드에 문제가 발생하더라도 다른 사용 가능한 노드가 이어 받는 형태로 페일오버 가능 
    - 1초이내 완료

#### 분산된 데이터 저장소간 동기방식 복제
- 데이터 저장소는 분산되어 관리
    - 각 데이터는 전체 데이터를 N 등분해서 자신의 전담 프라이머리 파티션과 백업으로 보조 파티션을 구성
- 동기방식으로 데이터 전달
    - 전달이 완료되어야 트랜잭션 완료
    - 저장소간 데이터 동기화는 일반적으로 MySQL의 복제와 다른 기능

#### 온라인 스키마 변경 
- 테이블에 칼럼이나 인덱스를 추가하면서 동시에 index, update 같은 dml을 수정할 수 있음
    - NDB 6.2 부터 지원
- ALTER TABLE, CREATE INDEX 명령에 ONLINE 키워드 사용

#### NoSQL
- NDB 클러스터는 MySQL 서버가 없어도 활용 가능

#### 네트워크 DB

### 3.5.2 NDB 클러스터 아키텍쳐 

#### NDB 클러스터 노드 종류
- NDB 클라스터는 관리/데이터/SQL 노드가 있고 SPoF 방지 위해 모두 이중화 될 수 있도록 구현됨 
- 일반적으로 한 노드는 하나의 물리장비에 맵핑되지만, 만드시 그래야하는건 아님 
    - 노드 -> 프로세스 

##### 관리 노드 
- 클러스터가 정상일때 하는 역할이 거의 없음 
- 클러스터의 전체 구조에 대한 정보나 정애 상황을 전파하는 역할 
- 클러스터를 시작하거나 새로운 노드 추가/제거시 반드시 필요

##### 데이터 노드 
- 클러스터 대한 전반 작업을 수행하는 노드 
- 데이터를 저장하는 스토리지를 관리하고 sql 노드에서 오는 데이터 조작 요청을 모두 처리 
- sql노드가 아닌 api노드의 요청도 처리 
- 하나의 클러스터에서 최대 48개의 데이터 노드 추가 가능 
- 데이터 노드는 내부적으로 클러스터링을 위해 파티션 하여 데이터를 복사/백업 해둠 
- 프라이머리 키에 의해 수직 파디션 됨 

##### sql 노드 
- 클러스터에 접속해 데이터를 읽고 쓰는 방법은 NDB api 활용
    - sql 서버를 통해 NDB 클러스터에 접속하는 겨우 sql 노드라 함 
- 일반적으로 sql 노드당 1개의 커넥션 -> 1개 트랜잭션

#### 데이터 노드간 파티션 관리 
- 하나의 클러스터에 데이터 노드는 2개 이상 존재 가능
- 각 데이터 노드는 일부 (파티션) 데이터만 가지며 데이터 노드는 2개의 파티션으로 구성됨 
- NDB 클러스터는 데이터 노드가 손상시에도 서비스 가능하도록 데이터를 파티션해 각 파티션을 최소 2개 이상의 데이터 노드로 복제해둠 
- 윗 부분이 원본 / 아랫부분이 백업된 파티션
    - 원본: primary 파티션
    - 복제: secondary 파티션
- 노드 그룹과 노드별 파티션은 명시적으로 설정 불가하며 데이터 노드 개수, 레플리카 개수에 따라 내부적으로 자동 결정됨 

### 3.5.3 클러스터간 복제 구성 
- NDB 클러스터도 MySQL 복제 적용 가능 / 클러스터간 복제 
- NDB 클러스터는 2개 이상의 MySQL 서버가 동시에 쓰기/읽기용 쿼리를 처리
    - 2개 이상의 서버에서 생성된 바이너리 로그를 처리하기 위해 데이터 노드는 MySQL 서버로 피드백 -> 일괄 처리
    - NDB Binlog injector 쓰레드가 데이터 노드로부터 받은 피드백을 바이너리 로그에 병합 역할
- NDB 클러스터의 바이너리 로그는 다른 클러스터 그룹으로 복제 가능
    - NDB 클러스가 아닌 일반 InnoDB 스토리지 테이블을 사용하는 테이블로 복제 가능 

## 3.6 Toku DB 스토리지 엔진
### 3.6.1 Fractal tree 인덱스 지원
#### B-Tree
- 일반적인 DBMS 인덱스 알고리즘
- 단점
    - 새로운 인덱스 값을 저장하기 위해 많은 비용 소요
    - 인덱스 데이터 단편화로 파생되는 문제 
        - insert, update, delete작업으로 인덱스 페이지 (블록) 내에 사용하지 못하는 공간 존재
        - 인덱스 페이지에 인덱스 레코드 1000 개를 저장할 수 있다면, 심할경우 50% 수준
        - 단일 레코드는 문제 없으나 range scan시 더 많은 디스크 읽기 발생
    - 인덱스 에이징 발생
        - 시간이 지날수록 인덱스의 충전율 (Fill factor) 가 떨어짐

#### Fractal tree
- 범용적인 목적으로 사용 가능

### 3.6.2 대용량 데이터와 빠른 insert 처리 
- Btree의 경우 새로운 레코드 추가시 랜덤 읽기 / 쓰기 작업 필요하나, 프렉탈 트리는 순차 읽기/ 쓰기 수준

### 3.6.3 트랜잭션 및 잠금 처리 
- 동시성 측면에서 트랜잭션 / 잠금 처리가 InnoDB 만큼 뛰어나지 않음 
- REPEATABLE_READ를 지원하지 않음 

### 3.6.4 기타 특징
- 평균적으로 10~50배정도 insert 작업이 빠름 
- 데이터 / 인덱스를 압축저장하여 디스크 공간이 적게 사용됨 

### 3.6.5 주 용도
- 빠르게 증가하는 데이터를 관리하는 것 
- 타 시스템으로부터 수집된 정보를 순간적으로 적재해야하는 경우 적합 

## 3.7 전문 검색엔진 
### 3.7.1 트리톤 전문 검색엔진 
- 아시아권 언어 지원위해 일본 개발한 스토리지 엔진 
- 한중일 아시아권 언어 지원, Senna 라이브러리를 이용한 빠른 인덱싱 / 검색 
- mysql 5.1 미만 지원 

### 3.7.2 mGroonga 전문 검색엔진 (플러그인)
- Groonga 단독 기능 + mGroonga 플러그인 

### 3.7.3 스핑크스 전문 검색엔진
- mysql 연관없이 자체적인 저장공간을 가지고 별도 프로세스로 작동 
- mysql 서버를 통해 접근할 수 있는 인터페이스만 제공하는 스토리지 엔진 
- n-gram 방식 인덱싱, 분산 처리 기능 뛰어남 

## 3.8 MySQL 로그 파일
- 상용 DBMS 비교시 진단도구 부족한 편, 로그파일로 원인 분석 가능 

### 3.8.1 에러 로그 파일
- 실행 중 발생한 에러/경고 메시지 출력되는 로그 파일 
- ```my.cnf``` 에서 log_error 파라미터로 정의된 경로에 있는 파일
    - 정의 안된경우, 데이터 디럭토리 (datadir) 하위 '.err' 파일 

- MySQL이 시작하는 과정과 관련된 정보 / 에러 메시지 
- 마지막으로 종료할 때 비정상 종료된 경우, 나타나는 InnoDB 트랜잭션 복구 메시지 
- 쿼리 처리 도중 발생한 문제에 대한 에러 메시지 
- 비정상적으로 종료된 커넥션 메시지 
- InnoDB의 모니터링 명령 / 상태 조회 명령 
- MySQL 종료 메시지 

### 3.8.2 제너럴 쿼리 로그 파일 
- MySQL 서버에서 실행되는 쿼리가 어떤게 있는지 찾아봐야할 때 

### 3.8.3 슬로우 쿼리 로그 
- long_query_time 설정값 이상 실행된 쿼리 기록됨 

### 3.8.4 바이너리 로그와 릴레이 로그 
- 바이너리 로그를 테스트 형태로 바꾸기 위해
```
$ $MYSQL_HOME/bin/mysqlbinlog binlog.0000012 > mysql-binlog.sql

$ $MYSQL_HOME/bin/mysqlbinlog  --start-datetime="2011-01-18 10:00:00"  --stop-datetime="2011-01-18 10:10:00" binlog.0000012 > mysql-binlog.sql

$ $MYSQL_HOME/bin/mysqlbinlog  --start-position=100000  --stop-position=200000 binlog.0000012 > mysql-binlog.sql

$ $MYSQL_HOME/bin/mysqlbinlog binlog.0000012 | mysql -uroot -p
```
