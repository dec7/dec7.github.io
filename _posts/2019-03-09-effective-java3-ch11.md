---
layout: post
title: "Effective Java 3e Ch11"
description: "Effective Java"
date: 2019-03-09
tags: [java,pattern]
comments: true
share: true
---

## 11. 동기화 
### 78. 공유중인 가변 데이터는 동기화해서 사용하라
- synchronized
  - 배타적 실행 보장 (한 쓰레드가 변경중이라 다른 쓰레드가 보지 못하게 막는 것)
  - 쓰레드간 안정적인 통신 보장
    - 한 쓰레드가 만든 변화를 볼 수 있게함
    - 자바 메모리 모델
      - openjdk vm hoisting 기법적용시 한 쓰레드가 다른 스레드의 변수를 볼 수 없게 됨
      - volatile 선언
        - 배타적 수행과는 무관하나 항상 가장 최근에 기록된 값을 읽게됨을 보장
- 해결책
  - 데이터를 공유하지 않는 것
  - 불변데이터만 공유
  - 가변데이터는 단일 쓰레드에서만 사용

### 79. 과도한 동기화는 피하라
- 응답불가, 안전실패를 피하기 위해 동기화메소드나 동기화 블록 안에서는 절대 클라이언트에 양도하지 말라
  - 동기화 메소드 안에서 재정의할 수 있는 메소드를 호출하면 안됨
  - 클라이언트가 넘겨준 객체를 호출해서도 안됨
- 동기화 영역에서는 가능한 일을 적게 하라
- 성능
  - 경쟁하는 시간이 진짜 비용, 병렬로 실행할 기회를 잃고 모든 코어가 메모리을 일관되게 보기 위한 지연시간
  - 가변클래스 작성시 
    - 1. 동시에 사용해야하는 경우 클래스가 외부에서 알아서 동기화하도록 하자
    - 2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자
      - 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을때만 선택

### 80. 스레드보다 실행자, 테스트, 스트림을 이용하자

### 81. wait, notify보다 동시성 유틸리티를 애용하라
- java.util.concurrent 세범주
  - 실행자 프레임워크
  - 동시성 컬렉션
    - List, Queue, Map 표준 컬렉션 인터페이스 + 동시성 기능
    - 동시성을 무력화하는 것 불가능, 외부 락 포함시 오히려 느려짐
  - 동기화 장치

### 82. 스레드 안전성을 문서화하라
- 목록
  - 불변
  - 무조건적 스레드 안전
  - 조건부 스레드 안전
  - 스레드 안전하지 않음
  - 스레드 적대적

### 83. 지연 초기화는 신중히 사용하라
- 상황
  - 대부분 상황에서 일반적인 초기화가 지연 초기화보다 낫다
  - 지연 초기화의 가장 단순한 방법은 synchronized 
  - 성능 때문에 정적 필드의 지연초기화가 필요하면 지연초기화 홀더 클래스 관용구 사용
  - 인스턴스 필드를 지연초기화해야한다면 DCL 관용구를 사용
    - 중복 초기화가 문제없는 경우라면 락 검사를 하지 않아도 됨
  - 만약 long, double 제외한 기본타일일 경우 필드 선언시 volatile을 사용하지 않아도 됨 (racy_single check)

### 84. 프로그램 동작을 스레드 스케쥴러에 기대지 말라
- 정확성, 성능이 스레드 스케즐러에 따라 달라지는 프로그램일 경우 다른 플랫폼에 이식하기 어려움
- 견고/빠릇/이식성 좋은 프로그램 작성 방법
  - 스레드 스케줄러가 고민하지 않도록: 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것
  - 실행 가능한 스레드 수와 전체 스레드 수를 구분해야함
    - 전체 쓰레드 수는 훨씬 많을 수 있음
    - 실행 가능한 스레드 수를 적게 유지하는 방법
      - 스레드가 작업 완료 후, 대기하도록 하는것
      - 당장 할일이 없으면 실행되서는 안됨
      - busy waiting이 가장 나쁨


  
